<html>
<head>
<title>ublox.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(0,0,255); }
.s4 { color: rgb(0,128,128); font-weight: bold; }
.s5 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
ublox.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">#!/usr/bin/env python</span><span class="s1"> 
</span><span class="s0">''' 
UBlox binary protocol handling 
 
Copyright Andrew Tridgell, October 2012 
Released under GNU GPL version 3 or later 
'''</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">struct 
</span><span class="s2">import </span><span class="s1">time, os 
</span><span class="s2">import </span><span class="s1">sys 
 
</span><span class="s0"># specify Python version</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s3">0</span><span class="s1">] &lt; </span><span class="s3">3</span><span class="s1">: </span><span class="s0"># we're on python 2.x.x</span><span class="s1"> 
    PYTHON_VERSION = </span><span class="s3">2</span><span class="s1"> 
</span><span class="s2">else</span><span class="s1">: 
    PYTHON_VERSION = </span><span class="s3">3</span><span class="s1"> 
 
</span><span class="s0"># protocol constants</span><span class="s1"> 
PREAMBLE1 = </span><span class="s3">0xb5</span><span class="s1"> 
PREAMBLE2 = </span><span class="s3">0x62</span><span class="s1"> 
 
</span><span class="s0"># message classes</span><span class="s1"> 
CLASS_NAV = </span><span class="s3">0x01</span><span class="s1"> 
CLASS_RXM = </span><span class="s3">0x02</span><span class="s1"> 
CLASS_INF = </span><span class="s3">0x04</span><span class="s1"> 
CLASS_ACK = </span><span class="s3">0x05</span><span class="s1"> 
CLASS_CFG = </span><span class="s3">0x06</span><span class="s1"> 
CLASS_MON = </span><span class="s3">0x0A</span><span class="s1"> 
CLASS_AID = </span><span class="s3">0x0B</span><span class="s1"> 
CLASS_TIM = </span><span class="s3">0x0D</span><span class="s1"> 
CLASS_ESF = </span><span class="s3">0x10</span><span class="s1"> 
 
</span><span class="s0"># ACK messages</span><span class="s1"> 
MSG_ACK_NACK = </span><span class="s3">0x00</span><span class="s1"> 
MSG_ACK_ACK = </span><span class="s3">0x01</span><span class="s1"> 
 
</span><span class="s0"># NAV messages</span><span class="s1"> 
MSG_NAV_POSECEF   = </span><span class="s3">0x1</span><span class="s1"> 
MSG_NAV_POSLLH    = </span><span class="s3">0x2</span><span class="s1"> 
MSG_NAV_STATUS    = </span><span class="s3">0x3</span><span class="s1"> 
MSG_NAV_DOP       = </span><span class="s3">0x4</span><span class="s1"> 
MSG_NAV_SOL       = </span><span class="s3">0x6</span><span class="s1"> 
MSG_NAV_POSUTM    = </span><span class="s3">0x8</span><span class="s1"> 
MSG_NAV_VELNED    = </span><span class="s3">0x12</span><span class="s1"> 
MSG_NAV_VELECEF   = </span><span class="s3">0x11</span><span class="s1"> 
MSG_NAV_TIMEGPS   = </span><span class="s3">0x20</span><span class="s1"> 
MSG_NAV_TIMEUTC   = </span><span class="s3">0x21</span><span class="s1"> 
MSG_NAV_CLOCK     = </span><span class="s3">0x22</span><span class="s1"> 
MSG_NAV_SVINFO    = </span><span class="s3">0x30</span><span class="s1"> 
MSG_NAV_AOPSTATUS = </span><span class="s3">0x60</span><span class="s1"> 
MSG_NAV_DGPS      = </span><span class="s3">0x31</span><span class="s1"> 
MSG_NAV_DOP       = </span><span class="s3">0x04</span><span class="s1"> 
MSG_NAV_EKFSTATUS = </span><span class="s3">0x40</span><span class="s1"> 
MSG_NAV_SBAS      = </span><span class="s3">0x32</span><span class="s1"> 
MSG_NAV_SOL       = </span><span class="s3">0x06</span><span class="s1"> 
MSG_NAV_PVT       = </span><span class="s3">0x07</span><span class="s1"> 
 
</span><span class="s0"># RXM messages</span><span class="s1"> 
MSG_RXM_RAW    = </span><span class="s3">0x10</span><span class="s1"> 
MSG_RXM_SFRB   = </span><span class="s3">0x11</span><span class="s1"> 
MSG_RXM_SVSI   = </span><span class="s3">0x20</span><span class="s1"> 
MSG_RXM_EPH    = </span><span class="s3">0x31</span><span class="s1"> 
MSG_RXM_ALM    = </span><span class="s3">0x30</span><span class="s1"> 
MSG_RXM_PMREQ  = </span><span class="s3">0x41</span><span class="s1"> 
 
</span><span class="s0"># AID messages</span><span class="s1"> 
MSG_AID_ALM    = </span><span class="s3">0x30</span><span class="s1"> 
MSG_AID_EPH    = </span><span class="s3">0x31</span><span class="s1"> 
MSG_AID_ALPSRV = </span><span class="s3">0x32</span><span class="s1"> 
MSG_AID_AOP    = </span><span class="s3">0x33</span><span class="s1"> 
MSG_AID_DATA   = </span><span class="s3">0x10</span><span class="s1"> 
MSG_AID_ALP    = </span><span class="s3">0x50</span><span class="s1"> 
MSG_AID_DATA   = </span><span class="s3">0x10</span><span class="s1"> 
MSG_AID_HUI    = </span><span class="s3">0x02</span><span class="s1"> 
MSG_AID_INI    = </span><span class="s3">0x01</span><span class="s1"> 
MSG_AID_REQ    = </span><span class="s3">0x00</span><span class="s1"> 
 
</span><span class="s0"># CFG messages</span><span class="s1"> 
MSG_CFG_PRT = </span><span class="s3">0x00</span><span class="s1"> 
MSG_CFG_ANT = </span><span class="s3">0x13</span><span class="s1"> 
MSG_CFG_DAT = </span><span class="s3">0x06</span><span class="s1"> 
MSG_CFG_EKF = </span><span class="s3">0x12</span><span class="s1"> 
MSG_CFG_ESFGWT = </span><span class="s3">0x29</span><span class="s1"> 
MSG_CFG_CFG = </span><span class="s3">0x09</span><span class="s1"> 
MSG_CFG_USB = </span><span class="s3">0x1b</span><span class="s1"> 
MSG_CFG_RATE = </span><span class="s3">0x08</span><span class="s1"> 
MSG_CFG_SET_RATE = </span><span class="s3">0x01</span><span class="s1"> 
MSG_CFG_NAV5 = </span><span class="s3">0x24</span><span class="s1"> 
MSG_CFG_FXN = </span><span class="s3">0x0E</span><span class="s1"> 
MSG_CFG_INF = </span><span class="s3">0x02</span><span class="s1"> 
MSG_CFG_ITFM = </span><span class="s3">0x39</span><span class="s1"> 
MSG_CFG_MSG = </span><span class="s3">0x01</span><span class="s1"> 
MSG_CFG_NAVX5 = </span><span class="s3">0x23</span><span class="s1"> 
MSG_CFG_NMEA = </span><span class="s3">0x17</span><span class="s1"> 
MSG_CFG_NVS = </span><span class="s3">0x22</span><span class="s1"> 
MSG_CFG_PM2 = </span><span class="s3">0x3B</span><span class="s1"> 
MSG_CFG_PM = </span><span class="s3">0x32</span><span class="s1"> 
MSG_CFG_RINV = </span><span class="s3">0x34</span><span class="s1"> 
MSG_CFG_RST = </span><span class="s3">0x04</span><span class="s1"> 
MSG_CFG_RXM = </span><span class="s3">0x11</span><span class="s1"> 
MSG_CFG_SBAS = </span><span class="s3">0x16</span><span class="s1"> 
MSG_CFG_TMODE2 = </span><span class="s3">0x3D</span><span class="s1"> 
MSG_CFG_TMODE = </span><span class="s3">0x1D</span><span class="s1"> 
MSG_CFG_TPS = </span><span class="s3">0x31</span><span class="s1"> 
MSG_CFG_TP = </span><span class="s3">0x07</span><span class="s1"> 
MSG_CFG_GNSS = </span><span class="s3">0x3E</span><span class="s1"> 
 
</span><span class="s0"># ESF messages</span><span class="s1"> 
MSG_ESF_MEAS   = </span><span class="s3">0x02</span><span class="s1"> 
MSG_ESF_STATUS = </span><span class="s3">0x10</span><span class="s1"> 
 
</span><span class="s0"># INF messages</span><span class="s1"> 
MSG_INF_DEBUG  = </span><span class="s3">0x04</span><span class="s1"> 
MSG_INF_ERROR  = </span><span class="s3">0x00</span><span class="s1"> 
MSG_INF_NOTICE = </span><span class="s3">0x02</span><span class="s1"> 
MSG_INF_TEST   = </span><span class="s3">0x03</span><span class="s1"> 
MSG_INF_WARNING= </span><span class="s3">0x01</span><span class="s1"> 
 
</span><span class="s0"># MON messages</span><span class="s1"> 
MSG_MON_SCHD  = </span><span class="s3">0x01</span><span class="s1"> 
MSG_MON_HW    = </span><span class="s3">0x09</span><span class="s1"> 
MSG_MON_HW2   = </span><span class="s3">0x0B</span><span class="s1"> 
MSG_MON_IO    = </span><span class="s3">0x02</span><span class="s1"> 
MSG_MON_MSGPP = </span><span class="s3">0x06</span><span class="s1"> 
MSG_MON_RXBUF = </span><span class="s3">0x07</span><span class="s1"> 
MSG_MON_RXR   = </span><span class="s3">0x21</span><span class="s1"> 
MSG_MON_TXBUF = </span><span class="s3">0x08</span><span class="s1"> 
MSG_MON_VER   = </span><span class="s3">0x04</span><span class="s1"> 
 
</span><span class="s0"># TIM messages</span><span class="s1"> 
MSG_TIM_TP   = </span><span class="s3">0x01</span><span class="s1"> 
MSG_TIM_TM2  = </span><span class="s3">0x03</span><span class="s1"> 
MSG_TIM_SVIN = </span><span class="s3">0x04</span><span class="s1"> 
MSG_TIM_VRFY = </span><span class="s3">0x06</span><span class="s1"> 
 
</span><span class="s0"># port IDs</span><span class="s1"> 
PORT_DDC    =</span><span class="s3">0</span><span class="s1"> 
PORT_SERIAL1=</span><span class="s3">1</span><span class="s1"> 
PORT_SERIAL2=</span><span class="s3">2</span><span class="s1"> 
PORT_USB    =</span><span class="s3">3</span><span class="s1"> 
PORT_SPI    =</span><span class="s3">4</span><span class="s1"> 
 
</span><span class="s0"># dynamic models</span><span class="s1"> 
DYNAMIC_MODEL_PORTABLE   = </span><span class="s3">0</span><span class="s1"> 
DYNAMIC_MODEL_STATIONARY = </span><span class="s3">2</span><span class="s1"> 
DYNAMIC_MODEL_PEDESTRIAN = </span><span class="s3">3</span><span class="s1"> 
DYNAMIC_MODEL_AUTOMOTIVE = </span><span class="s3">4</span><span class="s1"> 
DYNAMIC_MODEL_SEA        = </span><span class="s3">5</span><span class="s1"> 
DYNAMIC_MODEL_AIRBORNE1G = </span><span class="s3">6</span><span class="s1"> 
DYNAMIC_MODEL_AIRBORNE2G = </span><span class="s3">7</span><span class="s1"> 
DYNAMIC_MODEL_AIRBORNE4G = </span><span class="s3">8</span><span class="s1"> 
 
</span><span class="s0">#reset items</span><span class="s1"> 
RESET_HOT  = </span><span class="s3">0</span><span class="s1"> 
RESET_WARM = </span><span class="s3">1</span><span class="s1"> 
RESET_COLD = </span><span class="s3">0xFFFF</span><span class="s1"> 
 
RESET_HW            = </span><span class="s3">0</span><span class="s1"> 
RESET_SW            = </span><span class="s3">1</span><span class="s1"> 
RESET_SW_GPS        = </span><span class="s3">2</span><span class="s1"> 
RESET_HW_GRACEFUL   = </span><span class="s3">4</span><span class="s1"> 
RESET_GPS_STOP      = </span><span class="s3">8</span><span class="s1"> 
RESET_GPS_START     = </span><span class="s3">9</span><span class="s1"> 
 
</span><span class="s2">class </span><span class="s1">UBloxError(Exception): 
    </span><span class="s0">'''Ublox error class'''</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self, msg): 
        Exception.__init__(self, msg) 
        self.message = msg 
 
</span><span class="s2">class </span><span class="s1">UBloxAttrDict(dict): 
    </span><span class="s0">'''allow dictionary members as attributes'''</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self): 
        dict.__init__(self) 
 
    </span><span class="s2">def </span><span class="s1">__getattr__(self, name): 
        </span><span class="s2">try</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">self.__getitem__(name) 
        </span><span class="s2">except </span><span class="s1">KeyError: 
            </span><span class="s2">raise </span><span class="s1">AttributeError(name) 
 
    </span><span class="s2">def </span><span class="s1">__setattr__(self, name, value): 
        </span><span class="s2">if </span><span class="s1">self.__dict__.has_key(name): 
            </span><span class="s0"># allow set on normal attributes</span><span class="s1"> 
            dict.__setattr__(self, name, value) 
        </span><span class="s2">else</span><span class="s1">: 
            self.__setitem__(name, value) 
 
</span><span class="s2">def </span><span class="s1">ArrayParse(field): 
    </span><span class="s0">'''parse an array descriptor'''</span><span class="s1"> 
    arridx = field.find(</span><span class="s4">'['</span><span class="s1">) 
    </span><span class="s2">if </span><span class="s1">arridx == -</span><span class="s3">1</span><span class="s1">: 
        </span><span class="s2">return </span><span class="s1">(field, -</span><span class="s3">1</span><span class="s1">) 
    alen = int(field[arridx+</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]) 
    fieldname = field[:arridx] 
    </span><span class="s2">return </span><span class="s1">(fieldname, alen) 
 
</span><span class="s2">class </span><span class="s1">UBloxDescriptor: 
    </span><span class="s0">'''class used to describe the layout of a UBlox message'''</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self, name, msg_format, fields=[], count_field=</span><span class="s2">None</span><span class="s1">, format2=</span><span class="s2">None</span><span class="s1">, fields2=</span><span class="s2">None</span><span class="s1">): 
        self.name = name 
        self.msg_format = msg_format 
        self.fields = fields 
        self.count_field = count_field 
        self.format2 = format2 
        self.fields2 = fields2 
     
    </span><span class="s2">def </span><span class="s1">getf(self, fmt, buf, size): 
            f = list(struct.unpack(fmt, buf[:size])) 
            </span><span class="s2">return </span><span class="s1">f 
         
    </span><span class="s2">def </span><span class="s1">unpack(self, msg): 
        </span><span class="s0">'''unpack a UBloxMessage, creating the .fields and ._recs attributes in msg'''</span><span class="s1"> 
        msg._fields = {} 
 
        </span><span class="s0"># unpack main message blocks. A comm</span><span class="s1"> 
        formats = self.msg_format.split(</span><span class="s4">','</span><span class="s1">) 
        buf = msg._buf[</span><span class="s3">6</span><span class="s1">:-</span><span class="s3">2</span><span class="s1">] 
        count = </span><span class="s3">0</span><span class="s1"> 
        msg._recs = [] 
        fields = self.fields[:] 
         
        </span><span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">formats: 
            size1 = struct.calcsize(fmt) 
            </span><span class="s2">if </span><span class="s1">size1 &gt; len(buf): 
                </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">&quot;%s INVALID_SIZE1=%u&quot; </span><span class="s1">% (self.name, len(buf))) 
            f1 = self.getf(fmt, buf, size1) 
 
            i = </span><span class="s3">0</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">i &lt; len(f1): 
                field = fields.pop(</span><span class="s3">0</span><span class="s1">) 
                (fieldname, alen) = ArrayParse(field) 
                </span><span class="s2">if </span><span class="s1">alen == -</span><span class="s3">1</span><span class="s1">: 
                    msg._fields[fieldname] = f1[i] 
                    </span><span class="s2">if </span><span class="s1">self.count_field == fieldname: 
                        count = int(f1[i]) 
                    i += </span><span class="s3">1</span><span class="s1"> 
                </span><span class="s2">else</span><span class="s1">: 
                    msg._fields[fieldname] = [</span><span class="s3">0</span><span class="s1">]*alen 
                    </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">range(alen): 
                        msg._fields[fieldname][a] = f1[i] 
                        i += </span><span class="s3">1</span><span class="s1"> 
            buf = buf[size1:] 
            </span><span class="s2">if </span><span class="s1">len(buf) == </span><span class="s3">0</span><span class="s1">: 
                </span><span class="s2">break</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">self.count_field == </span><span class="s4">'_remaining'</span><span class="s1">: 
            count = len(buf) / struct.calcsize(self.format2) 
 
        </span><span class="s2">if </span><span class="s1">count == </span><span class="s3">0</span><span class="s1">: 
            msg._unpacked = </span><span class="s2">True</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">len(buf) != </span><span class="s3">0</span><span class="s1">: 
                </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">&quot;EXTRA_BYTES=%u&quot; </span><span class="s1">% len(buf)) 
            </span><span class="s2">return</span><span class="s1"> 
 
        size2 = struct.calcsize(self.format2) 
        </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(count): 
            r = UBloxAttrDict() 
            </span><span class="s2">if </span><span class="s1">size2 &gt; len(buf): 
                </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">&quot;INVALID_SIZE=%u, &quot; </span><span class="s1">% len(buf)) 
            f2 = self.getf(self.format2, buf, size2)     
             
            </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(self.fields2)): 
                r[self.fields2[i]] = f2[i] 
            buf = buf[size2:] 
            msg._recs.append(r) 
        </span><span class="s2">if </span><span class="s1">len(buf) != </span><span class="s3">0</span><span class="s1">: 
            </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">&quot;EXTRA_BYTES=%u&quot; </span><span class="s1">% len(buf)) 
        msg._unpacked = </span><span class="s2">True</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">pack(self, msg, msg_class=</span><span class="s2">None</span><span class="s1">, msg_id=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s0">'''pack a UBloxMessage from the .fields and ._recs attributes in msg'''</span><span class="s1"> 
        f1 = [] 
        </span><span class="s2">if </span><span class="s1">msg_class </span><span class="s2">is None</span><span class="s1">: 
            msg_class = msg.msg_class() 
        </span><span class="s2">if </span><span class="s1">msg_id </span><span class="s2">is None</span><span class="s1">: 
            msg_id = msg.msg_id() 
        msg._buf = </span><span class="s4">''</span><span class="s1"> 
 
        fields = self.fields[:] 
        </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields: 
            (fieldname, alen) = ArrayParse(f) 
            </span><span class="s2">if not </span><span class="s1">fieldname </span><span class="s2">in </span><span class="s1">msg._fields: 
                </span><span class="s2">break</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">alen == -</span><span class="s3">1</span><span class="s1">: 
                f1.append(msg._fields[fieldname]) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">range(alen): 
                    f1.append(msg._fields[fieldname][a])                     
        </span><span class="s2">try</span><span class="s1">: 
            </span><span class="s0"># try full length message</span><span class="s1"> 
            fmt = self.msg_format.replace(</span><span class="s4">','</span><span class="s1">, </span><span class="s4">''</span><span class="s1">) 
            msg._buf = struct.pack(fmt, *tuple(f1)) 
        </span><span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e: 
            </span><span class="s0"># try without optional part</span><span class="s1"> 
            fmt = self.msg_format.split(</span><span class="s4">','</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] 
            msg._buf = struct.pack(fmt, *tuple(f1)) 
 
        length = len(msg._buf) 
        </span><span class="s2">if </span><span class="s1">msg._recs: 
            length += len(msg._recs) * struct.calcsize(self.format2) 
        header = struct.pack(</span><span class="s4">'&lt;BBBBH'</span><span class="s1">, PREAMBLE1, PREAMBLE2, msg_class, msg_id, length) 
        msg._buf = header + msg._buf 
 
        </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">msg._recs: 
            f2 = [] 
            </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.fields2: 
                f2.append(r[f]) 
            msg._buf += struct.pack(self.format2, *tuple(f2))             
        msg._buf += struct.pack(</span><span class="s4">'&lt;BB'</span><span class="s1">, *msg.checksum(data=msg._buf[</span><span class="s3">2</span><span class="s1">:])) 
 
    </span><span class="s2">def </span><span class="s1">format(self, msg): 
        </span><span class="s0">'''return a formatted string for a message'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">msg._unpacked: 
            self.unpack(msg) 
        ret = self.name + </span><span class="s4">': '</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.fields: 
            (fieldname, alen) = ArrayParse(f) 
            </span><span class="s2">if not </span><span class="s1">fieldname </span><span class="s2">in </span><span class="s1">msg._fields: 
                </span><span class="s2">continue</span><span class="s1"> 
            v = msg._fields[fieldname] 
            </span><span class="s2">if </span><span class="s1">isinstance(v, list): 
                ret += </span><span class="s4">'%s=[' </span><span class="s1">% fieldname 
                </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">range(alen): 
                    ret += </span><span class="s4">'%s, ' </span><span class="s1">% v[a] 
                ret = ret[:-</span><span class="s3">2</span><span class="s1">] + </span><span class="s4">'], '</span><span class="s1"> 
            </span><span class="s2">elif </span><span class="s1">isinstance(v, str): 
                ret += </span><span class="s4">'%s=&quot;%s&quot;, ' </span><span class="s1">% (f, v.rstrip(</span><span class="s4">' </span><span class="s2">\0</span><span class="s4">'</span><span class="s1">)) 
            </span><span class="s2">else</span><span class="s1">: 
                ret += </span><span class="s4">'%s=%s, ' </span><span class="s1">% (f, v) 
        </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">msg._recs: 
            ret += </span><span class="s4">'[ '</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.fields2: 
                v = r[f] 
                ret += </span><span class="s4">'%s=%s, ' </span><span class="s1">% (f, v) 
            ret = ret[:-</span><span class="s3">2</span><span class="s1">] + </span><span class="s4">' ], '</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">ret[:-</span><span class="s3">2</span><span class="s1">] 
         
 
</span><span class="s0"># list of supported message types.</span><span class="s1"> 
msg_types = { 
    (CLASS_ACK, MSG_ACK_ACK)    : UBloxDescriptor(</span><span class="s4">'ACK_ACK'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BB'</span><span class="s1">,  
                                                  [</span><span class="s4">'clsID'</span><span class="s1">, </span><span class="s4">'msgID'</span><span class="s1">]), 
    (CLASS_ACK, MSG_ACK_NACK)   : UBloxDescriptor(</span><span class="s4">'ACK_NACK'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BB'</span><span class="s1">,  
                                                  [</span><span class="s4">'clsID'</span><span class="s1">, </span><span class="s4">'msgID'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_USB)    : UBloxDescriptor(</span><span class="s4">'CFG_USB'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;HHHHHH32s32s32s'</span><span class="s1">, 
                                                  [</span><span class="s4">'vendorID'</span><span class="s1">, </span><span class="s4">'productID'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">, </span><span class="s4">'powerConsumption'</span><span class="s1">, 
                                                   </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'vendorString'</span><span class="s1">, </span><span class="s4">'productString'</span><span class="s1">, </span><span class="s4">'serialNumber'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_PRT)    : UBloxDescriptor(</span><span class="s4">'CFG_PRT'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBHIIHHHH'</span><span class="s1">, 
                                                  [</span><span class="s4">'portID'</span><span class="s1">, </span><span class="s4">'reserved0'</span><span class="s1">, </span><span class="s4">'txReady'</span><span class="s1">, </span><span class="s4">'mode'</span><span class="s1">, </span><span class="s4">'baudRate'</span><span class="s1">, </span><span class="s4">'inProtoMask'</span><span class="s1">,  
                                                   </span><span class="s4">'outProtoMask'</span><span class="s1">, </span><span class="s4">'reserved4'</span><span class="s1">, </span><span class="s4">'reserved5'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_CFG)    : UBloxDescriptor(</span><span class="s4">'CFG_CFG'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;III,B'</span><span class="s1">, 
                                                  [</span><span class="s4">'clearMask'</span><span class="s1">, </span><span class="s4">'saveMask'</span><span class="s1">, </span><span class="s4">'loadMask'</span><span class="s1">, </span><span class="s4">'deviceMask'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_RST)    : UBloxDescriptor(</span><span class="s4">'CFG_RST'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;HBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'navBbrMask '</span><span class="s1">, </span><span class="s4">'resetMode'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_SBAS)   : UBloxDescriptor(</span><span class="s4">'CFG_SBAS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBBBI'</span><span class="s1">, 
                                                  [</span><span class="s4">'mode'</span><span class="s1">, </span><span class="s4">'usage'</span><span class="s1">, </span><span class="s4">'maxSBAS'</span><span class="s1">, </span><span class="s4">'scanmode2'</span><span class="s1">, </span><span class="s4">'scanmode1'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_GNSS)   : UBloxDescriptor(</span><span class="s4">'CFG_GNSS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBBBBBBBI'</span><span class="s1">, 
                                                  [</span><span class="s4">'msgVer'</span><span class="s1">, </span><span class="s4">'numTrkChHw'</span><span class="s1">, </span><span class="s4">'numTrkChUse'</span><span class="s1">, </span><span class="s4">'numConfigBlocks'</span><span class="s1">, </span><span class="s4">'gnssId'</span><span class="s1">, 
                                                   </span><span class="s4">'resTrkCh'</span><span class="s1">, </span><span class="s4">'maxTrkCh'</span><span class="s1">, </span><span class="s4">'resetved1'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_RATE)   : UBloxDescriptor(</span><span class="s4">'CFG_RATE'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;HHH'</span><span class="s1">, 
                                                  [</span><span class="s4">'measRate'</span><span class="s1">, </span><span class="s4">'navRate'</span><span class="s1">, </span><span class="s4">'timeRef'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_MSG)    : UBloxDescriptor(</span><span class="s4">'CFG_MSG'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BB6B'</span><span class="s1">, 
                                                  [</span><span class="s4">'msgClass'</span><span class="s1">, </span><span class="s4">'msgId'</span><span class="s1">, </span><span class="s4">'rates[6]'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_POSLLH) : UBloxDescriptor(</span><span class="s4">'NAV_POSLLH'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiiiII'</span><span class="s1">,  
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'Longitude'</span><span class="s1">, </span><span class="s4">'Latitude'</span><span class="s1">, </span><span class="s4">'height'</span><span class="s1">, </span><span class="s4">'hMSL'</span><span class="s1">, </span><span class="s4">'hAcc'</span><span class="s1">, </span><span class="s4">'vAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_PVT) : UBloxDescriptor(</span><span class="s4">'NAV_PVT'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IHBBBBBBIiBBBBiiiiIIiiiiiIIHBBBBBBihH'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'year'</span><span class="s1">, </span><span class="s4">'month'</span><span class="s1">, </span><span class="s4">'day'</span><span class="s1">, </span><span class="s4">'hour'</span><span class="s1">, </span><span class="s4">'min'</span><span class="s1">, </span><span class="s4">'sec'</span><span class="s1">, </span><span class="s4">'valid'</span><span class="s1">, 
                                                   </span><span class="s4">'tAcc'</span><span class="s1">, </span><span class="s4">'nano'</span><span class="s1">, </span><span class="s4">'fixType'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'flags2'</span><span class="s1">, </span><span class="s4">'numSV'</span><span class="s1">, </span><span class="s4">'lon'</span><span class="s1">, 
                                                   </span><span class="s4">'lat'</span><span class="s1">, </span><span class="s4">'height'</span><span class="s1">, </span><span class="s4">'hMSL'</span><span class="s1">, </span><span class="s4">'hAcc'</span><span class="s1">, </span><span class="s4">'vAcc'</span><span class="s1">, </span><span class="s4">'velN'</span><span class="s1">, </span><span class="s4">'velE'</span><span class="s1">, </span><span class="s4">'velD'</span><span class="s1">, 
                                                   </span><span class="s4">'gSpeed'</span><span class="s1">, </span><span class="s4">'headMot'</span><span class="s1">, </span><span class="s4">'sAcc'</span><span class="s1">, </span><span class="s4">'headAcc'</span><span class="s1">, </span><span class="s4">'pDOP'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">, 
                                                   </span><span class="s4">'reserved2'</span><span class="s1">, </span><span class="s4">'reserved3'</span><span class="s1">,</span><span class="s4">'reserved4'</span><span class="s1">,</span><span class="s4">'reserved5'</span><span class="s1">,</span><span class="s4">'reserved6'</span><span class="s1">, 
                                                   </span><span class="s4">'headVeh'</span><span class="s1">, </span><span class="s4">'magDec'</span><span class="s1">, </span><span class="s4">'magAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_VELNED) : UBloxDescriptor(</span><span class="s4">'NAV_VELNED'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiiIIiII'</span><span class="s1">,  
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'velN'</span><span class="s1">, </span><span class="s4">'velE'</span><span class="s1">, </span><span class="s4">'velD'</span><span class="s1">, </span><span class="s4">'speed'</span><span class="s1">, </span><span class="s4">'gSpeed'</span><span class="s1">, </span><span class="s4">'heading'</span><span class="s1">,  
                                                   </span><span class="s4">'sAcc'</span><span class="s1">, </span><span class="s4">'cAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_DOP)    : UBloxDescriptor(</span><span class="s4">'NAV_DOP'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IHHHHHHH'</span><span class="s1">,  
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'gDOP'</span><span class="s1">, </span><span class="s4">'pDOP'</span><span class="s1">, </span><span class="s4">'tDOP'</span><span class="s1">, </span><span class="s4">'vDOP'</span><span class="s1">, </span><span class="s4">'hDOP'</span><span class="s1">, </span><span class="s4">'nDOP'</span><span class="s1">, </span><span class="s4">'eDOP'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_STATUS) : UBloxDescriptor(</span><span class="s4">'NAV_STATUS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IBBBBII'</span><span class="s1">,  
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'gpsFix'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'fixStat'</span><span class="s1">, </span><span class="s4">'flags2'</span><span class="s1">, </span><span class="s4">'ttff'</span><span class="s1">, </span><span class="s4">'msss'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_SOL)    : UBloxDescriptor(</span><span class="s4">'NAV_SOL'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IihBBiiiIiiiIHBBI'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'fTOW'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'gpsFix'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'ecefX'</span><span class="s1">, </span><span class="s4">'ecefY'</span><span class="s1">, </span><span class="s4">'ecefZ'</span><span class="s1">, 
                                                   </span><span class="s4">'pAcc'</span><span class="s1">, </span><span class="s4">'ecefVX'</span><span class="s1">, </span><span class="s4">'ecefVY'</span><span class="s1">, </span><span class="s4">'ecefVZ'</span><span class="s1">, </span><span class="s4">'sAcc'</span><span class="s1">, </span><span class="s4">'pDOP'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">,  
                                                   </span><span class="s4">'numSV'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_POSUTM) : UBloxDescriptor(</span><span class="s4">'NAV_POSUTM'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;Iiiibb'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'East'</span><span class="s1">, </span><span class="s4">'North'</span><span class="s1">, </span><span class="s4">'Alt'</span><span class="s1">, </span><span class="s4">'Zone'</span><span class="s1">, </span><span class="s4">'Hem'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_SBAS)   : UBloxDescriptor(</span><span class="s4">'NAV_SBAS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IBBbBBBBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'geo'</span><span class="s1">, </span><span class="s4">'mode'</span><span class="s1">, </span><span class="s4">'sys'</span><span class="s1">, </span><span class="s4">'service'</span><span class="s1">, </span><span class="s4">'cnt'</span><span class="s1">, </span><span class="s4">'reserved01'</span><span class="s1">, </span><span class="s4">'reserved02'</span><span class="s1">, </span><span class="s4">'reserved03' </span><span class="s1">], 
                                                  </span><span class="s4">'cnt'</span><span class="s1">, 
                                                  </span><span class="s4">'BBBBBBhHh'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'udre'</span><span class="s1">, </span><span class="s4">'svSys'</span><span class="s1">, </span><span class="s4">'svService'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">, 
                                                   </span><span class="s4">'prc'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">, </span><span class="s4">'ic'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_POSECEF): UBloxDescriptor(</span><span class="s4">'NAV_POSECEF'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiiI'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'ecefX'</span><span class="s1">, </span><span class="s4">'ecefY'</span><span class="s1">, </span><span class="s4">'ecefZ'</span><span class="s1">, </span><span class="s4">'pAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_VELECEF): UBloxDescriptor(</span><span class="s4">'NAV_VELECEF'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiiI'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'ecefVX'</span><span class="s1">, </span><span class="s4">'ecefVY'</span><span class="s1">, </span><span class="s4">'ecefVZ'</span><span class="s1">, </span><span class="s4">'sAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_TIMEGPS): UBloxDescriptor(</span><span class="s4">'NAV_TIMEGPS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IihbBI'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'fTOW'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'leapS'</span><span class="s1">, </span><span class="s4">'valid'</span><span class="s1">, </span><span class="s4">'tAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_TIMEUTC): UBloxDescriptor(</span><span class="s4">'NAV_TIMEUTC'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IIiHBBBBBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'tAcc'</span><span class="s1">, </span><span class="s4">'nano'</span><span class="s1">, </span><span class="s4">'year'</span><span class="s1">, </span><span class="s4">'month'</span><span class="s1">, </span><span class="s4">'day'</span><span class="s1">, </span><span class="s4">'hour'</span><span class="s1">, </span><span class="s4">'min'</span><span class="s1">, </span><span class="s4">'sec'</span><span class="s1">, </span><span class="s4">'valid'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_CLOCK)  : UBloxDescriptor(</span><span class="s4">'NAV_CLOCK'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiII'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'clkB'</span><span class="s1">, </span><span class="s4">'clkD'</span><span class="s1">, </span><span class="s4">'tAcc'</span><span class="s1">, </span><span class="s4">'fAcc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_DGPS)   : UBloxDescriptor(</span><span class="s4">'NAV_DGPS'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IihhBBH'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'age'</span><span class="s1">, </span><span class="s4">'baseId'</span><span class="s1">, </span><span class="s4">'baseHealth'</span><span class="s1">, </span><span class="s4">'numCh'</span><span class="s1">, </span><span class="s4">'status'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">], 
                                                  </span><span class="s4">'numCh'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBHff'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'ageC'</span><span class="s1">, </span><span class="s4">'prc'</span><span class="s1">, </span><span class="s4">'prrc'</span><span class="s1">]), 
    (CLASS_NAV, MSG_NAV_SVINFO) : UBloxDescriptor(</span><span class="s4">'NAV_SVINFO'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IBBH'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'numCh'</span><span class="s1">, </span><span class="s4">'globalFlags'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">], 
                                                  </span><span class="s4">'numCh'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBBBBbhi'</span><span class="s1">, 
                                                  [</span><span class="s4">'chn'</span><span class="s1">, </span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'quality'</span><span class="s1">, </span><span class="s4">'cno'</span><span class="s1">, </span><span class="s4">'elev'</span><span class="s1">, </span><span class="s4">'azim'</span><span class="s1">, </span><span class="s4">'prRes'</span><span class="s1">]), 
    (CLASS_RXM, MSG_RXM_SVSI)   : UBloxDescriptor(</span><span class="s4">'RXM_SVSI'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IhBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'numVis'</span><span class="s1">, </span><span class="s4">'numSV'</span><span class="s1">], 
                                                  </span><span class="s4">'numSV'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBhbB'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'svFlag'</span><span class="s1">, </span><span class="s4">'azim'</span><span class="s1">, </span><span class="s4">'elev'</span><span class="s1">, </span><span class="s4">'age'</span><span class="s1">]), 
    (CLASS_RXM, MSG_RXM_EPH)    : UBloxDescriptor(</span><span class="s4">'RXM_EPH'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;II , 8I 8I 8I'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'how'</span><span class="s1">, 
                                                   </span><span class="s4">'sf1d[8]'</span><span class="s1">, </span><span class="s4">'sf2d[8]'</span><span class="s1">, </span><span class="s4">'sf3d[8]'</span><span class="s1">]), 
    (CLASS_AID, MSG_AID_EPH)    : UBloxDescriptor(</span><span class="s4">'AID_EPH'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;II , 8I 8I 8I'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'how'</span><span class="s1">, 
                                                   </span><span class="s4">'sf1d[8]'</span><span class="s1">, </span><span class="s4">'sf2d[8]'</span><span class="s1">, </span><span class="s4">'sf3d[8]'</span><span class="s1">]), 
    (CLASS_AID, MSG_AID_AOP)    : UBloxDescriptor(</span><span class="s4">'AID_AOP'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;B47B , 48B 48B 48B'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'data[47]'</span><span class="s1">, </span><span class="s4">'optional0[48]'</span><span class="s1">, </span><span class="s4">'optional1[48]'</span><span class="s1">, </span><span class="s4">'optional1[48]'</span><span class="s1">]), 
    (CLASS_RXM, MSG_RXM_RAW)   : UBloxDescriptor(</span><span class="s4">'RXM_RAW'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;ihBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'iTOW'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'numSV'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">], 
                                                  </span><span class="s4">'numSV'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;ddfBbbB'</span><span class="s1">, 
                                                  [</span><span class="s4">'cpMes'</span><span class="s1">, </span><span class="s4">'prMes'</span><span class="s1">, </span><span class="s4">'doMes'</span><span class="s1">, </span><span class="s4">'sv'</span><span class="s1">, </span><span class="s4">'mesQI'</span><span class="s1">, </span><span class="s4">'cno'</span><span class="s1">, </span><span class="s4">'lli'</span><span class="s1">]), 
    (CLASS_RXM, MSG_RXM_SFRB)  : UBloxDescriptor(</span><span class="s4">'RXM_SFRB'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BB10I'</span><span class="s1">, 
                                                  [</span><span class="s4">'chn'</span><span class="s1">, </span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'dwrd[10]'</span><span class="s1">]), 
    (CLASS_AID, MSG_AID_ALM)   : UBloxDescriptor(</span><span class="s4">'AID_ALM'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;II'</span><span class="s1">, 
                                                 </span><span class="s4">'_remaining'</span><span class="s1">, 
                                                 </span><span class="s4">'I'</span><span class="s1">, 
                                                 [</span><span class="s4">'dwrd'</span><span class="s1">]), 
    (CLASS_RXM, MSG_RXM_ALM)   : UBloxDescriptor(</span><span class="s4">'RXM_ALM'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;II , 8I'</span><span class="s1">, 
                                                  [</span><span class="s4">'svid'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'dwrd[8]'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_NAV5)   : UBloxDescriptor(</span><span class="s4">'CFG_NAV5'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;HBBiIbBHHHHBBIII'</span><span class="s1">, 
                                                  [</span><span class="s4">'mask'</span><span class="s1">, </span><span class="s4">'dynModel'</span><span class="s1">, </span><span class="s4">'fixMode'</span><span class="s1">, </span><span class="s4">'fixedAlt'</span><span class="s1">, </span><span class="s4">'fixedAltVar'</span><span class="s1">, </span><span class="s4">'minElev'</span><span class="s1">,  
                                                   </span><span class="s4">'drLimit'</span><span class="s1">, </span><span class="s4">'pDop'</span><span class="s1">, </span><span class="s4">'tDop'</span><span class="s1">, </span><span class="s4">'pAcc'</span><span class="s1">, </span><span class="s4">'tAcc'</span><span class="s1">, </span><span class="s4">'staticHoldThresh'</span><span class="s1">,  
                                                   </span><span class="s4">'dgpsTimeOut'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">, </span><span class="s4">'reserved3'</span><span class="s1">, </span><span class="s4">'reserved4'</span><span class="s1">]), 
    (CLASS_CFG, MSG_CFG_NAVX5)   : UBloxDescriptor(</span><span class="s4">'CFG_NAVX5'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;HHIBBBBBBBBBBHIBBBBBBHII'</span><span class="s1">, 
                                                  [</span><span class="s4">'version'</span><span class="s1">, </span><span class="s4">'mask1'</span><span class="s1">, </span><span class="s4">'reserved0'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">, </span><span class="s4">'reserved2'</span><span class="s1">, 
                                                   </span><span class="s4">'minSVs'</span><span class="s1">, </span><span class="s4">'maxSVs'</span><span class="s1">, </span><span class="s4">'minCNO'</span><span class="s1">, </span><span class="s4">'reserved5'</span><span class="s1">, </span><span class="s4">'iniFix3D'</span><span class="s1">,  
                                                   </span><span class="s4">'reserved6'</span><span class="s1">, </span><span class="s4">'reserved7'</span><span class="s1">, </span><span class="s4">'reserved8'</span><span class="s1">, </span><span class="s4">'wknRollover'</span><span class="s1">, 
                                                   </span><span class="s4">'reserved9'</span><span class="s1">, </span><span class="s4">'reserved10'</span><span class="s1">, </span><span class="s4">'reserved11'</span><span class="s1">, 
                                                   </span><span class="s4">'usePPP'</span><span class="s1">, </span><span class="s4">'useAOP'</span><span class="s1">, </span><span class="s4">'reserved12'</span><span class="s1">, </span><span class="s4">'reserved13'</span><span class="s1">,  
                                                   </span><span class="s4">'aopOrbMaxErr'</span><span class="s1">, </span><span class="s4">'reserved3'</span><span class="s1">, </span><span class="s4">'reserved4'</span><span class="s1">]), 
    (CLASS_MON, MSG_MON_HW)     : UBloxDescriptor(</span><span class="s4">'MON_HW'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IIIIHHBBBBIB25BHIII'</span><span class="s1">, 
                                                  [</span><span class="s4">'pinSel'</span><span class="s1">, </span><span class="s4">'pinBank'</span><span class="s1">, </span><span class="s4">'pinDir'</span><span class="s1">, </span><span class="s4">'pinVal'</span><span class="s1">, </span><span class="s4">'noisePerMS'</span><span class="s1">, </span><span class="s4">'agcCnt'</span><span class="s1">, </span><span class="s4">'aStatus'</span><span class="s1">, 
                                                   </span><span class="s4">'aPower'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">, </span><span class="s4">'usedMask'</span><span class="s1">,  
                                                   </span><span class="s4">'VP[25]'</span><span class="s1">,                                                   
                                                   </span><span class="s4">'jamInd'</span><span class="s1">, </span><span class="s4">'reserved3'</span><span class="s1">, </span><span class="s4">'pinInq'</span><span class="s1">, 
                                                   </span><span class="s4">'pullH'</span><span class="s1">, </span><span class="s4">'pullL'</span><span class="s1">]), 
    (CLASS_MON, MSG_MON_HW2)    : UBloxDescriptor(</span><span class="s4">'MON_HW2'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;bBbBB3BI8BI4B'</span><span class="s1">, 
                                                  [</span><span class="s4">'ofsI'</span><span class="s1">, </span><span class="s4">'magI'</span><span class="s1">, </span><span class="s4">'ofsQ'</span><span class="s1">, </span><span class="s4">'magQ'</span><span class="s1">, </span><span class="s4">'cfgSource'</span><span class="s1">, </span><span class="s4">'reserved1[3]'</span><span class="s1">, 
                                                   </span><span class="s4">'lowLevCfg'</span><span class="s1">, </span><span class="s4">'reserved2[8]'</span><span class="s1">, </span><span class="s4">'postStatus'</span><span class="s1">, </span><span class="s4">'reserved3[4]'</span><span class="s1">]), 
    (CLASS_MON, MSG_MON_SCHD)   : UBloxDescriptor(</span><span class="s4">'MON_SCHD'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IIIIHHHBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'tskRun'</span><span class="s1">, </span><span class="s4">'tskSchd'</span><span class="s1">, </span><span class="s4">'tskOvrr'</span><span class="s1">, </span><span class="s4">'tskReg'</span><span class="s1">, </span><span class="s4">'stack'</span><span class="s1">, 
                                                   </span><span class="s4">'stackSize'</span><span class="s1">, </span><span class="s4">'CPUIdle'</span><span class="s1">, </span><span class="s4">'flySly'</span><span class="s1">, </span><span class="s4">'ptlSly'</span><span class="s1">]), 
    (CLASS_MON, MSG_MON_VER)    : UBloxDescriptor(</span><span class="s4">'MON_VER'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;30s10s,30s'</span><span class="s1">, 
                                                  [</span><span class="s4">'swVersion'</span><span class="s1">, </span><span class="s4">'hwVersion'</span><span class="s1">, </span><span class="s4">'romVersion'</span><span class="s1">], 
                                                  </span><span class="s4">'_remaining'</span><span class="s1">, 
                                                  </span><span class="s4">'30s'</span><span class="s1">, 
                                                  [</span><span class="s4">'extension'</span><span class="s1">]), 
    (CLASS_TIM, MSG_TIM_TP)     : UBloxDescriptor(</span><span class="s4">'TIM_TP'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IIiHBB'</span><span class="s1">, 
                                                  [</span><span class="s4">'towMS'</span><span class="s1">, </span><span class="s4">'towSubMS'</span><span class="s1">, </span><span class="s4">'qErr'</span><span class="s1">, </span><span class="s4">'week'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">]), 
    (CLASS_TIM, MSG_TIM_TM2)    : UBloxDescriptor(</span><span class="s4">'TIM_TM2'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;BBHHHIIIII'</span><span class="s1">, 
                                                  [</span><span class="s4">'ch'</span><span class="s1">, </span><span class="s4">'flags'</span><span class="s1">, </span><span class="s4">'count'</span><span class="s1">, </span><span class="s4">'wnR'</span><span class="s1">, </span><span class="s4">'wnF'</span><span class="s1">, </span><span class="s4">'towMsR'</span><span class="s1">, </span><span class="s4">'towSubMsR'</span><span class="s1">,  
                                                   </span><span class="s4">'towMsF'</span><span class="s1">, </span><span class="s4">'towSubMsF'</span><span class="s1">, </span><span class="s4">'accEst'</span><span class="s1">]), 
    (CLASS_TIM, MSG_TIM_SVIN)   : UBloxDescriptor(</span><span class="s4">'TIM_SVIN'</span><span class="s1">, 
                                                  </span><span class="s4">'&lt;IiiiIIBBH'</span><span class="s1">, 
                                                  [</span><span class="s4">'dur'</span><span class="s1">, </span><span class="s4">'meanX'</span><span class="s1">, </span><span class="s4">'meanY'</span><span class="s1">, </span><span class="s4">'meanZ'</span><span class="s1">, </span><span class="s4">'meanV'</span><span class="s1">, 
                                                   </span><span class="s4">'obs'</span><span class="s1">, </span><span class="s4">'valid'</span><span class="s1">, </span><span class="s4">'active'</span><span class="s1">, </span><span class="s4">'reserved1'</span><span class="s1">]), 
    (CLASS_INF, MSG_INF_ERROR)  : UBloxDescriptor(</span><span class="s4">'INF_ERR'</span><span class="s1">, </span><span class="s4">'&lt;18s'</span><span class="s1">, [</span><span class="s4">'str'</span><span class="s1">]), 
    (CLASS_INF, MSG_INF_DEBUG)  : UBloxDescriptor(</span><span class="s4">'INF_DEBUG'</span><span class="s1">, </span><span class="s4">'&lt;18s'</span><span class="s1">, [</span><span class="s4">'str'</span><span class="s1">]) 
} 
 
 
</span><span class="s2">class </span><span class="s1">UBloxMessage: 
    </span><span class="s0">'''UBlox message class - holds a UBX binary message'''</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self): 
        self._buf = </span><span class="s5">b&quot;&quot;</span><span class="s1"> 
        self._fields = {} 
        self._recs = [] 
        self._unpacked = </span><span class="s2">False</span><span class="s1"> 
        self.debug_level = </span><span class="s3">0</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">__str__(self): 
        </span><span class="s0">'''format a message as a string'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.valid(): 
            </span><span class="s2">return </span><span class="s4">'UBloxMessage(INVALID)'</span><span class="s1"> 
        type = self.msg_type() 
        </span><span class="s2">if </span><span class="s1">type </span><span class="s2">in </span><span class="s1">msg_types: 
            </span><span class="s2">return </span><span class="s1">msg_types[type].format(self) 
        </span><span class="s2">return </span><span class="s4">'UBloxMessage(UNKNOWN %s, %u)' </span><span class="s1">% (str(type), self.msg_length()) 
 
    </span><span class="s2">def </span><span class="s1">__getattr__(self, name): 
        </span><span class="s0">'''allow access to message fields'''</span><span class="s1"> 
        </span><span class="s2">try</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">self._fields[name] 
        </span><span class="s2">except </span><span class="s1">KeyError: 
            </span><span class="s2">if </span><span class="s1">name == </span><span class="s4">'recs'</span><span class="s1">: 
                </span><span class="s2">return </span><span class="s1">self._recs 
            </span><span class="s2">raise </span><span class="s1">AttributeError(name) 
 
    </span><span class="s2">def </span><span class="s1">__setattr__(self, name, value): 
        </span><span class="s0">'''allow access to message fields'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">name.startswith(</span><span class="s4">'_'</span><span class="s1">): 
            self.__dict__[name] = value 
        </span><span class="s2">else</span><span class="s1">: 
            self._fields[name] = value 
 
    </span><span class="s2">def </span><span class="s1">have_field(self, name): 
        </span><span class="s0">'''return True if a message contains the given field'''</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._fields 
 
    </span><span class="s2">def </span><span class="s1">debug(self, level, msg): 
        </span><span class="s0">'''write a debug message'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.debug_level &gt;= level: 
            print(msg) 
 
    </span><span class="s2">def </span><span class="s1">unpack(self): 
        </span><span class="s0">'''unpack a message'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.valid(): 
            </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">'INVALID MESSAGE'</span><span class="s1">) 
        type = self.msg_type() 
        </span><span class="s2">if not </span><span class="s1">type </span><span class="s2">in </span><span class="s1">msg_types: 
            </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">'Unknown message %s length=%u' </span><span class="s1">% (str(type), len(self._buf))) 
        msg_types[type].unpack(self) 
 
    </span><span class="s2">def </span><span class="s1">pack(self): 
        </span><span class="s0">'''pack a message'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.valid(): 
            </span><span class="s2">raise </span><span class="s1">UbloxError(</span><span class="s4">'INVALID MESSAGE'</span><span class="s1">) 
        type = self.msg_type() 
        </span><span class="s2">if not </span><span class="s1">type </span><span class="s2">in </span><span class="s1">msg_types: 
            </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">'Unknown message %s' </span><span class="s1">% str(type)) 
        msg_types[type].pack(self) 
 
    </span><span class="s2">def </span><span class="s1">name(self): 
        </span><span class="s0">'''return the short string name for a message'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.valid(): 
            </span><span class="s2">raise </span><span class="s1">UbloxError(</span><span class="s4">'INVALID MESSAGE'</span><span class="s1">) 
        type = self.msg_type() 
        </span><span class="s2">if not </span><span class="s1">type </span><span class="s2">in </span><span class="s1">msg_types: 
            </span><span class="s2">raise </span><span class="s1">UBloxError(</span><span class="s4">'Unknown message %s length=%u' </span><span class="s1">% (str(type), len(self._buf))) 
        </span><span class="s2">return </span><span class="s1">msg_types[type].name 
     
    </span><span class="s2">if </span><span class="s1">PYTHON_VERSION == </span><span class="s3">2</span><span class="s1">: 
        </span><span class="s2">def </span><span class="s1">msg_class(self): 
            </span><span class="s0">'''return the message class'''</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ord(self._buf[</span><span class="s3">2</span><span class="s1">]) 
 
        </span><span class="s2">def </span><span class="s1">msg_id(self): 
            </span><span class="s0">'''return the message id within the class'''</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ord(self._buf[</span><span class="s3">3</span><span class="s1">]) 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">def </span><span class="s1">msg_class(self): 
            </span><span class="s0">'''return the message class'''</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">(self._buf[</span><span class="s3">2</span><span class="s1">]) 
 
        </span><span class="s2">def </span><span class="s1">msg_id(self): 
            </span><span class="s0">'''return the message id within the class'''</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">(self._buf[</span><span class="s3">3</span><span class="s1">]) 
 
    </span><span class="s2">def </span><span class="s1">msg_type(self): 
        </span><span class="s0">'''return the message type tuple (class, id)'''</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">(self.msg_class(), self.msg_id()) 
 
    </span><span class="s2">def </span><span class="s1">msg_length(self): 
        </span><span class="s0">'''return the payload length'''</span><span class="s1"> 
        (payload_length,) = struct.unpack(</span><span class="s4">'&lt;H'</span><span class="s1">, self._buf[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]) 
        </span><span class="s2">return </span><span class="s1">payload_length 
 
    </span><span class="s2">def </span><span class="s1">valid_so_far(self): 
        </span><span class="s0">'''check if the message is valid so far'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">PYTHON_VERSION == </span><span class="s3">2</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">len(self._buf) &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">ord(self._buf[</span><span class="s3">0</span><span class="s1">]) != PREAMBLE1: 
                </span><span class="s2">return False</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">len(self._buf) &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">ord(self._buf[</span><span class="s3">1</span><span class="s1">]) != PREAMBLE2: 
                self.debug(</span><span class="s3">1</span><span class="s1">, </span><span class="s4">&quot;bad pre2&quot;</span><span class="s1">) 
                </span><span class="s2">return False</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">len(self._buf) &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">(self._buf[</span><span class="s3">0</span><span class="s1">]) != PREAMBLE1: 
                </span><span class="s2">return False</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">len(self._buf) &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">(self._buf[</span><span class="s3">1</span><span class="s1">]) != PREAMBLE2: 
                self.debug(</span><span class="s3">1</span><span class="s1">, </span><span class="s4">&quot;bad pre2&quot;</span><span class="s1">) 
                </span><span class="s2">return False</span><span class="s1"> 
                 
        </span><span class="s2">if </span><span class="s1">self.needed_bytes() == </span><span class="s3">0 </span><span class="s2">and not </span><span class="s1">self.valid(): 
            </span><span class="s2">if </span><span class="s1">len(self._buf) &gt; </span><span class="s3">8</span><span class="s1">: 
                self.debug(</span><span class="s3">1</span><span class="s1">, </span><span class="s4">&quot;bad checksum len=%u needed=%u&quot; </span><span class="s1">% (len(self._buf), self.needed_bytes())) 
            </span><span class="s2">else</span><span class="s1">: 
                self.debug(</span><span class="s3">1</span><span class="s1">, </span><span class="s4">&quot;bad len len=%u needed=%u&quot; </span><span class="s1">% (len(self._buf), self.needed_bytes())) 
            </span><span class="s2">return False</span><span class="s1"> 
        </span><span class="s2">return True</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">add(self, bytes): 
        </span><span class="s0">'''add some bytes to a message'''</span><span class="s1"> 
 
        self._buf += bytes 
        </span><span class="s2">while not </span><span class="s1">self.valid_so_far() </span><span class="s2">and </span><span class="s1">len(self._buf) &gt; </span><span class="s3">0</span><span class="s1">: 
            </span><span class="s4">'''handle corrupted streams'''</span><span class="s1"> 
            self._buf = self._buf[</span><span class="s3">1</span><span class="s1">:] 
        </span><span class="s2">if </span><span class="s1">self.needed_bytes() &lt; </span><span class="s3">0</span><span class="s1">: 
            self._buf = </span><span class="s5">b&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">checksum(self, data=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s0">'''return a checksum tuple for a message'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">: 
            data = self._buf[</span><span class="s3">2</span><span class="s1">:-</span><span class="s3">2</span><span class="s1">] 
        cs = </span><span class="s3">0</span><span class="s1"> 
        ck_a = </span><span class="s3">0</span><span class="s1"> 
        ck_b = </span><span class="s3">0</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">data: 
            </span><span class="s2">if </span><span class="s1">type(i) </span><span class="s2">is </span><span class="s1">str: 
                
                ck_a = (ck_a + ord(i)) &amp; </span><span class="s3">0xFF</span><span class="s1"> 
            </span><span class="s2">else</span><span class="s1">: 
                ck_a = (ck_a + i) &amp; </span><span class="s3">0xFF</span><span class="s1"> 
            ck_b = (ck_b + ck_a) &amp; </span><span class="s3">0xFF</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">(ck_a, ck_b) 
 
    </span><span class="s2">def </span><span class="s1">valid_checksum(self): 
        </span><span class="s0">'''check if the checksum is OK'''</span><span class="s1"> 
        (ck_a, ck_b) = self.checksum() 
        d = self._buf[</span><span class="s3">2</span><span class="s1">:-</span><span class="s3">2</span><span class="s1">] 
        (ck_a2, ck_b2) = struct.unpack(</span><span class="s4">'&lt;BB'</span><span class="s1">, self._buf[-</span><span class="s3">2</span><span class="s1">:]) 
        </span><span class="s2">return </span><span class="s1">ck_a == ck_a2 </span><span class="s2">and </span><span class="s1">ck_b == ck_b2 
 
    </span><span class="s2">def </span><span class="s1">needed_bytes(self): 
        </span><span class="s0">'''return number of bytes still needed'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">len(self._buf) &lt; </span><span class="s3">6</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s3">8 </span><span class="s1">- len(self._buf) 
        </span><span class="s2">return </span><span class="s1">self.msg_length() + </span><span class="s3">8 </span><span class="s1">- len(self._buf) 
 
    </span><span class="s2">def </span><span class="s1">valid(self): 
        </span><span class="s0">'''check if a message is valid'''</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">len(self._buf) &gt;= </span><span class="s3">8 </span><span class="s2">and </span><span class="s1">self.needed_bytes() == </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.valid_checksum() 
 
 
</span><span class="s2">class </span><span class="s1">UBlox: 
    </span><span class="s0">'''main UBlox control class. 
 
    port can be a file (for reading only) or a serial device 
    '''</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self, port, baudrate=</span><span class="s3">115200</span><span class="s1">, timeout=</span><span class="s3">0</span><span class="s1">): 
 
        self.serial_device = port 
        self.baudrate = baudrate 
        self.use_sendrecv = </span><span class="s2">False</span><span class="s1"> 
        self.read_only = </span><span class="s2">False</span><span class="s1"> 
        self.use_xfer = </span><span class="s2">False</span><span class="s1"> 
        self.debug_level = </span><span class="s3">0</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">self.serial_device.startswith(</span><span class="s4">&quot;tcp:&quot;</span><span class="s1">): 
            </span><span class="s2">import </span><span class="s1">socket 
            a = self.serial_device.split(</span><span class="s4">':'</span><span class="s1">) 
            destination_addr = (a[</span><span class="s3">1</span><span class="s1">], int(a[</span><span class="s3">2</span><span class="s1">])) 
            self.dev = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
            self.dev.connect(destination_addr) 
            self.dev.setblocking(</span><span class="s3">1</span><span class="s1">) 
            self.dev.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, </span><span class="s3">1</span><span class="s1">)             
            self.use_sendrecv = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">os.path.isfile(self.serial_device): 
            self.read_only = </span><span class="s2">True</span><span class="s1"> 
            self.dev = open(self.serial_device, mode=</span><span class="s4">'rb'</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">self.serial_device.startswith(</span><span class="s4">&quot;spi:&quot;</span><span class="s1">): 
            </span><span class="s2">import </span><span class="s1">spidev 
            bus, cs = map(int, self.serial_device.split(</span><span class="s4">':'</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">].split(</span><span class="s4">'.'</span><span class="s1">)) 
            </span><span class="s0">#print(bus, cs)</span><span class="s1"> 
            self.use_xfer = </span><span class="s2">True</span><span class="s1"> 
            self.dev = spidev.SpiDev() 
            self.dev.open(bus, cs) 
            </span><span class="s0">#We reuse baudrate parameter but it's difficult to get default paramaters right. So it's better to specify them explicitly </span><span class="s1"> 
            self.dev.max_speed_hz = baudrate 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">import </span><span class="s1">serial 
            self.dev = serial.Serial(self.serial_device, baudrate=self.baudrate, 
                                     dsrdtr=</span><span class="s2">False</span><span class="s1">, rtscts=</span><span class="s2">False</span><span class="s1">, xonxoff=</span><span class="s2">False</span><span class="s1">, timeout=timeout) 
        self.logfile = </span><span class="s2">None</span><span class="s1"> 
        self.log = </span><span class="s2">None</span><span class="s1"> 
        self.preferred_dynamic_model = </span><span class="s2">None</span><span class="s1"> 
        self.preferred_usePPP = </span><span class="s2">None</span><span class="s1"> 
        self.preferred_dgps_timeout = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">close(self): 
        </span><span class="s0">'''close the device'''</span><span class="s1"> 
        self.dev.close() 
        self.dev = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">set_debug(self, debug_level): 
        </span><span class="s0">'''set debug level'''</span><span class="s1"> 
        self.debug_level = debug_level 
 
    </span><span class="s2">def </span><span class="s1">debug(self, level, msg): 
        </span><span class="s0">'''write a debug message'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.debug_level &gt;= level: 
            print(msg) 
 
    </span><span class="s2">def </span><span class="s1">set_logfile(self, logfile, append=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s0">'''setup logging to a file'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.log </span><span class="s2">is not None</span><span class="s1">: 
            self.log.close() 
            self.log = </span><span class="s2">None</span><span class="s1"> 
        self.logfile = logfile 
        </span><span class="s2">if </span><span class="s1">self.logfile </span><span class="s2">is not None</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">append: 
                mode = </span><span class="s4">'ab'</span><span class="s1"> 
            </span><span class="s2">else</span><span class="s1">: 
                mode = </span><span class="s4">'wb'</span><span class="s1"> 
            self.log = open(self.logfile, mode=mode) 
 
    </span><span class="s2">def </span><span class="s1">set_preferred_dynamic_model(self, model): 
        </span><span class="s0">'''set the preferred dynamic model for receiver'''</span><span class="s1"> 
        self.preferred_dynamic_model = model 
        </span><span class="s2">if </span><span class="s1">model </span><span class="s2">is not None</span><span class="s1">: 
            self.configure_poll(CLASS_CFG, MSG_CFG_NAV5) 
 
    </span><span class="s2">def </span><span class="s1">set_preferred_dgps_timeout(self, timeout): 
        </span><span class="s0">'''set the preferred DGPS timeout for receiver'''</span><span class="s1"> 
        self.preferred_dgps_timeout = timeout 
        </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">is not None</span><span class="s1">: 
            self.configure_poll(CLASS_CFG, MSG_CFG_NAV5) 
 
    </span><span class="s2">def </span><span class="s1">set_preferred_usePPP(self, usePPP): 
        </span><span class="s0">'''set the preferred usePPP setting for the receiver'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">usePPP </span><span class="s2">is None</span><span class="s1">: 
            self.preferred_usePPP = </span><span class="s2">None</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s1"> 
        self.preferred_usePPP = int(usePPP) 
        self.configure_poll(CLASS_CFG, MSG_CFG_NAVX5) 
 
    </span><span class="s2">def </span><span class="s1">nmea_checksum(self, msg): 
        d = msg[</span><span class="s3">1</span><span class="s1">:] 
        cs = </span><span class="s3">0</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">d: 
            cs ^= ord(i) 
        </span><span class="s2">return </span><span class="s1">cs 
 
    </span><span class="s2">def </span><span class="s1">write(self, buf): 
        </span><span class="s0">'''write some bytes'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.read_only: 
            </span><span class="s2">if </span><span class="s1">self.use_sendrecv: 
                </span><span class="s2">return </span><span class="s1">self.dev.send(buf) 
            </span><span class="s2">elif </span><span class="s1">self.use_xfer: 
                spiBuf = [] </span><span class="s0"># form buf</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">buf: 
                    </span><span class="s2">if </span><span class="s1">type(b) </span><span class="s2">is </span><span class="s1">str: 
                         
                        spiBuf.append(ord(b)) 
                    </span><span class="s2">else</span><span class="s1">: 
                        spiBuf.append(b) 
                </span><span class="s2">return </span><span class="s1">self.dev.xfer2(spiBuf) 
            </span><span class="s2">return </span><span class="s1">self.dev.write(buf) 
 
    </span><span class="s2">def </span><span class="s1">read(self, n): 
        </span><span class="s0">'''read some bytes'''</span><span class="s1"> 
         
        </span><span class="s2">if </span><span class="s1">self.use_sendrecv: 
            </span><span class="s2">import </span><span class="s1">socket 
            </span><span class="s2">try</span><span class="s1">: 
                buf = self.dev.recv(n) 
                </span><span class="s2">return </span><span class="s1">buf 
            </span><span class="s2">except </span><span class="s1">socket.error </span><span class="s2">as </span><span class="s1">e: 
                </span><span class="s2">return </span><span class="s5">b''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.use_xfer: 
            buf = self.dev.readbytes(n) 
            </span><span class="s2">return </span><span class="s1">buf 
             
        buf = self.dev.read(n) 
        </span><span class="s2">return </span><span class="s1">buf 
 
    </span><span class="s2">def </span><span class="s1">send_nmea(self, msg): 
        </span><span class="s2">if not </span><span class="s1">self.read_only: 
            s = msg + </span><span class="s4">&quot;*%02X&quot; </span><span class="s1">% self.nmea_checksum(msg) 
             
            </span><span class="s2">if </span><span class="s1">PYTHON_VERSION == </span><span class="s3">2</span><span class="s1">: 
                b = bytearray() 
                b.extend(s) 
            </span><span class="s2">else</span><span class="s1">: 
                b = bytearray() 
                b.extend(map(ord, s)) 
            self.write(b) 
 
    </span><span class="s2">def </span><span class="s1">set_binary(self): 
        </span><span class="s0">'''put a UBlox into binary mode using a NMEA string'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.read_only: 
            print(</span><span class="s4">&quot;try set binary at %u&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,0,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,1,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,2,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,3,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,4,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
            self.send_nmea(</span><span class="s4">&quot;$PUBX,41,5,0007,0001,%u,0&quot; </span><span class="s1">% self.baudrate) 
 
    </span><span class="s2">def </span><span class="s1">seek_percent(self, pct): 
        </span><span class="s0">'''seek to the given percentage of a file'''</span><span class="s1"> 
        self.dev.seek(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">) 
        filesize = self.dev.tell() 
        self.dev.seek(pct*</span><span class="s3">0.01</span><span class="s1">*filesize) 
 
    </span><span class="s2">def </span><span class="s1">special_handling(self, msg): 
        </span><span class="s0">'''handle automatic configuration changes'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">msg.name() == </span><span class="s4">'CFG_NAV5'</span><span class="s1">: 
            msg.unpack() 
            sendit = </span><span class="s2">False</span><span class="s1"> 
            pollit = </span><span class="s2">False</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">self.preferred_dynamic_model </span><span class="s2">is not None and </span><span class="s1">msg.dynModel != self.preferred_dynamic_model: 
                msg.dynModel = self.preferred_dynamic_model 
                sendit = </span><span class="s2">True</span><span class="s1"> 
                pollit = </span><span class="s2">True</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">self.preferred_dgps_timeout </span><span class="s2">is not None and </span><span class="s1">msg.dgpsTimeOut != self.preferred_dgps_timeout: 
                msg.dgpsTimeOut = self.preferred_dgps_timeout 
                self.debug(</span><span class="s3">2</span><span class="s1">, </span><span class="s4">&quot;Setting dgpsTimeOut=%u&quot; </span><span class="s1">% msg.dgpsTimeOut) 
                sendit = </span><span class="s2">True</span><span class="s1"> 
                </span><span class="s0"># we don't re-poll for this one, as some receivers refuse to set it</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">sendit: 
                msg.pack() 
                self.send(msg) 
                </span><span class="s2">if </span><span class="s1">pollit: 
                    self.configure_poll(CLASS_CFG, MSG_CFG_NAV5) 
        </span><span class="s2">if </span><span class="s1">msg.name() == </span><span class="s4">'CFG_NAVX5' </span><span class="s2">and </span><span class="s1">self.preferred_usePPP </span><span class="s2">is not None</span><span class="s1">: 
            msg.unpack() 
            </span><span class="s2">if </span><span class="s1">msg.usePPP != self.preferred_usePPP: 
                msg.usePPP = self.preferred_usePPP 
                msg.mask = </span><span class="s3">1</span><span class="s1">&lt;&lt;</span><span class="s3">13</span><span class="s1"> 
                msg.pack() 
                self.send(msg) 
                self.configure_poll(CLASS_CFG, MSG_CFG_NAVX5) 
 
    </span><span class="s2">def </span><span class="s1">receive_message_nonblocking(self, seconds=</span><span class="s3">5</span><span class="s1">): 
        </span><span class="s0">'''nonblocking receive of one ublox message'''</span><span class="s1"> 
        </span><span class="s2">with </span><span class="s1">Timeout(seconds=seconds): 
            </span><span class="s2">return </span><span class="s1">self.receive_message() 
 
    </span><span class="s2">def </span><span class="s1">receive_message(self, ignore_eof=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s0">'''blocking receive of one ublox message'''</span><span class="s1"> 
        msg = UBloxMessage() 
        </span><span class="s2">while True</span><span class="s1">: 
            n = msg.needed_bytes() 
            b = self.read(n) 
            </span><span class="s2">if not </span><span class="s1">b: 
                </span><span class="s2">if </span><span class="s1">ignore_eof: 
                    time.sleep(</span><span class="s3">0.01</span><span class="s1">) 
                    </span><span class="s2">continue</span><span class="s1"> 
                </span><span class="s2">return None</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">self.use_xfer:  
                </span><span class="s2">if </span><span class="s1">PYTHON_VERSION == </span><span class="s3">3</span><span class="s1">: 
                    bb = bytearray() 
                    </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">b: 
                        bb.append(c) 
                    b = bb 
                </span><span class="s2">else</span><span class="s1">: 
                    b = </span><span class="s4">&quot;&quot;</span><span class="s1">.join([chr(c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">b]) </span><span class="s0"># here str</span><span class="s1"> 
            msg.add(b) 
            </span><span class="s2">if </span><span class="s1">self.log </span><span class="s2">is not None</span><span class="s1">: 
                self.log.write(b) 
                self.log.flush() 
            </span><span class="s2">if </span><span class="s1">msg.valid(): 
                self.special_handling(msg) 
                </span><span class="s2">return </span><span class="s1">msg 
 
    </span><span class="s2">def </span><span class="s1">receive_message_noerror(self, ignore_eof=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s0">'''blocking receive of one ublox message, ignoring errors'''</span><span class="s1"> 
        </span><span class="s2">try</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">self.receive_message(ignore_eof=ignore_eof) 
        </span><span class="s2">except </span><span class="s1">UBloxError </span><span class="s2">as </span><span class="s1">e: 
            print(e) 
            </span><span class="s2">return None</span><span class="s1"> 
        </span><span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e: 
            </span><span class="s0"># Occasionally we get hit with 'resource temporarily unavailable'</span><span class="s1"> 
            </span><span class="s0"># messages here on the serial device, catch them too.</span><span class="s1"> 
            print(e) 
            </span><span class="s2">return None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">send(self, msg): 
        </span><span class="s0">'''send a preformatted ublox message'''</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">msg.valid(): 
            self.debug(</span><span class="s3">1</span><span class="s1">, </span><span class="s4">&quot;invalid send&quot;</span><span class="s1">) 
            </span><span class="s2">return</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self.read_only: 
            self.write(msg._buf)         
 
    </span><span class="s2">def </span><span class="s1">send_message(self, msg_class, msg_id, payload): 
        </span><span class="s0">'''send a ublox message with class, id and payload'''</span><span class="s1"> 
        msg = UBloxMessage() 
        msg._buf = struct.pack(</span><span class="s4">'&lt;BBBBH'</span><span class="s1">, </span><span class="s3">0xb5</span><span class="s1">, </span><span class="s3">0x62</span><span class="s1">, msg_class, msg_id, len(payload)) 
 
        msg._buf += payload  
 
        (ck_a, ck_b) = msg.checksum(msg._buf[</span><span class="s3">2</span><span class="s1">:]) 
        msg._buf += struct.pack(</span><span class="s4">'&lt;BB'</span><span class="s1">, ck_a, ck_b) 
        self.send(msg) 
 
    </span><span class="s2">def </span><span class="s1">configure_solution_rate(self, rate_ms=</span><span class="s3">200</span><span class="s1">, nav_rate=</span><span class="s3">1</span><span class="s1">, timeref=</span><span class="s3">0</span><span class="s1">): 
        </span><span class="s0">'''configure the solution rate in milliseconds'''</span><span class="s1"> 
        payload = struct.pack(</span><span class="s4">'&lt;HHH'</span><span class="s1">, rate_ms, nav_rate, timeref) 
        self.send_message(CLASS_CFG, MSG_CFG_RATE, payload) 
 
    </span><span class="s2">def </span><span class="s1">configure_message_rate(self, msg_class, msg_id, rate): 
        </span><span class="s0">'''configure the message rate for a given message'''</span><span class="s1"> 
        payload = struct.pack(</span><span class="s4">'&lt;BBB'</span><span class="s1">, msg_class, msg_id, rate) 
        self.send_message(CLASS_CFG, MSG_CFG_SET_RATE, payload) 
 
    </span><span class="s2">def </span><span class="s1">configure_port(self, port=</span><span class="s3">1</span><span class="s1">, inMask=</span><span class="s3">3</span><span class="s1">, outMask=</span><span class="s3">3</span><span class="s1">, mode=</span><span class="s3">2240</span><span class="s1">, baudrate=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s0">'''configure a IO port'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">baudrate </span><span class="s2">is None</span><span class="s1">: 
            baudrate = self.baudrate 
        payload = struct.pack(</span><span class="s4">'&lt;BBHIIHHHH'</span><span class="s1">, port, </span><span class="s3">0xff</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, mode, baudrate, inMask, outMask, </span><span class="s3">0xFFFF</span><span class="s1">, </span><span class="s3">0xFFFF</span><span class="s1">) 
        self.send_message(CLASS_CFG, MSG_CFG_PRT, payload) 
 
    </span><span class="s2">def </span><span class="s1">configure_loadsave(self, clearMask=</span><span class="s3">0</span><span class="s1">, saveMask=</span><span class="s3">0</span><span class="s1">, loadMask=</span><span class="s3">0</span><span class="s1">, deviceMask=</span><span class="s3">0</span><span class="s1">): 
        </span><span class="s0">'''configure configuration load/save'''</span><span class="s1"> 
        payload = struct.pack(</span><span class="s4">'&lt;IIIB'</span><span class="s1">, clearMask, saveMask, loadMask, deviceMask) 
        self.send_message(CLASS_CFG, MSG_CFG_CFG, payload) 
 
    </span><span class="s2">def </span><span class="s1">configure_poll(self, msg_class, msg_id, payload=</span><span class="s5">b''</span><span class="s1">): 
        </span><span class="s0">'''poll a configuration message'''</span><span class="s1"> 
        self.send_message(msg_class, msg_id, payload) 
 
    </span><span class="s2">def </span><span class="s1">configure_poll_port(self, portID=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s0">'''poll a port configuration'''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">portID </span><span class="s2">is None</span><span class="s1">: 
            self.configure_poll(CLASS_CFG, MSG_CFG_PRT) 
        </span><span class="s2">else</span><span class="s1">: 
            self.configure_poll(CLASS_CFG, MSG_CFG_PRT, struct.pack(</span><span class="s4">'&lt;B'</span><span class="s1">, portID)) 
 
    </span><span class="s2">def </span><span class="s1">configure_min_max_sats(self, min_sats=</span><span class="s3">4</span><span class="s1">, max_sats=</span><span class="s3">32</span><span class="s1">): 
        </span><span class="s0">'''Set the minimum/maximum number of satellites for a solution in the NAVX5 message'''</span><span class="s1"> 
        payload = struct.pack(</span><span class="s4">'&lt;HHIBBBBBBBBBBHIBBBBBBHII'</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">4</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, min_sats, max_sats, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">) 
        self.send_message(CLASS_CFG, MSG_CFG_NAVX5, payload) 
 
    </span><span class="s2">def </span><span class="s1">module_reset(self, set, mode): 
        </span><span class="s0">''' Reset the module for hot/warm/cold start'''</span><span class="s1"> 
        payload = struct.pack(</span><span class="s4">'&lt;HBB'</span><span class="s1">, set, mode, </span><span class="s3">0</span><span class="s1">) 
        self.send_message(CLASS_CFG, MSG_CFG_RST, payload) 
 
</span><span class="s2">class </span><span class="s1">TimeoutError(Exception): 
    </span><span class="s2">pass</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">signal 
</span><span class="s2">class </span><span class="s1">Timeout: 
    </span><span class="s2">def </span><span class="s1">__init__(self, seconds=</span><span class="s3">1</span><span class="s1">, msg=</span><span class="s4">'Timeout'</span><span class="s1">): 
        self.seconds = seconds 
        self.msg = msg 
    </span><span class="s2">def </span><span class="s1">handle_timeout(self, signum, frame): 
        </span><span class="s2">raise </span><span class="s1">TimeoutError(self.msg) 
    </span><span class="s2">def </span><span class="s1">__enter__(self): 
        signal.signal(signal.SIGALRM, self.handle_timeout) 
        signal.alarm(self.seconds) 
    </span><span class="s2">def </span><span class="s1">__exit__(self, type, value, traceback): 
        signal.alarm(</span><span class="s3">0</span><span class="s1">) 
</span></pre>
</body>
</html>